{
  "exerciseSheet": false,
  "blocks": [
    {
      "type": "text",
      "text": "# **Definitions and Notations for Waterproof**\n\nThis file contains a list of additional notation that can be used in writing mathematical proofs."
    },
    {
      "type": "code",
      "text": "Require Import Qreals.\nRequire Import Reals.\nRequire Import Rbase.\nRequire Import Rfunctions.\nRequire Import SeqSeries.\nRequire Import Rtrigo.\nRequire Import Ranalysis.\nRequire Import Integration.\nRequire Import micromega.Lra.\nRequire Import Omega.\nRequire Import Max.\n\nRequire Export wplib.Definitions.SetDefinitions.\n\nOpen Scope nat_scope.\nOpen Scope R_scope."
    },
    {
      "type": "text",
      "text": "## **Quantifiers**\nAllow unicode characters ∀ and ∃ for readability."
    },
    {
      "type": "code",
      "text": "Notation \"'for' 'all' x .. y , P\" := (forall x, .. (forall y, P) ..)\n  (at level 200, x binder, y binder, right associativity,\n  format \"'[ ' '[ ' for  all  x .. y ']' , '//'  P ']'\") : type_scope.\n\nNotation \"∀ x .. y , P\" := (forall x, .. (forall y, P) ..)\n  (at level 200, x binder, y binder, right associativity,\n  only parsing) : type_scope.\n\nNotation \"'there' 'exists' x .. y , P \" := (exists x, .. (exists y, P) ..)\n  (at level 200, x binder, y binder, right associativity,\n  format \"'[ ' '[ ' there  exists  x .. y  ']' , '//'  P ']'\") : type_scope.\n\nNotation \"∃ x .. y , P \" := (exists x, .. (exists y, P) ..)\n  (at level 200, x binder, y binder, right associativity,\n  only parsing) : type_scope.\n  \nNotation \"'fun' x .. y '↦' t\" := (fun x => .. (fun y => t) ..)\n  (at level 200, x binder, y binder, right associativity,\n  format \"'[ ' '[ ' 'fun' x .. y ']' '↦' '/' t ']'\")."
    },
    {
      "type": "text",
      "text": "## **Set symbols, implications**\nThe following notations deal with sets."
    },
    {
      "type": "code",
      "text": "Notation \"x ∨ y\" := (x \\/ y) (at level 85, right associativity) : type_scope.\nNotation \"x ∧ y\" := (x /\\ y) (at level 80, right associativity) : type_scope.\nNotation \"x → y\" := (x -> y)\n  (at level 99, y at level 200, right associativity,\n   only parsing): type_scope.\nNotation \"x ⇒ y\" := (x -> y)\n  (at level 99, y at level 200, right associativity,\n   only parsing): type_scope.\n(* the notation below is fun, but is no good for functions *)\n(* need to see if this can be adapted so it only uses \n   this notation for propositions *)\n(*Notation \"'if' x 'then' y\" := (x -> y)\n  (at level 99, y at level 200, right associativity): prop_scope.*)\nNotation \"x ⇨ y\" := (x -> y)\n  (at level 99, y at level 200, right associativity): type_scope.\n\nNotation \"x ↔ y\" := (x <-> y) (at level 95, no associativity): type_scope.\nNotation \"x ⇔ y\" := (x <-> y) (at level 95, no associativity): type_scope.\nNotation \"¬ x\" := (~x) (at level 75, right associativity) : type_scope.\n(* TODO: the below definition doesn't work very nicely *)\nNotation \"x ↦ y\" := (fun x => y) (at level 0)."
    },
    {
      "type": "text",
      "text": "We also provide a way to write intervals (on the real line)."
    },
    {
      "type": "code",
      "text": "Notation \"[ x , y ]\" := (interval_cl_cl x y).\nNotation \"[ x , y )\" := (interval_cl_op x y).\nNotation \"( x , y ]\" := (interval_op_cl x y).\nNotation \"( x , y )\" := (interval_op_op x y)."
    },
    {
      "type": "text",
      "text": "## **(In)equalities**\nAllowing unicode characters for uniqualities."
    },
    {
      "type": "code",
      "text": "Notation \"x ≠ y\" := (x <> y) (at level 70) : type_scope.\n\nNotation \"x ≤ y\" := (le x y) (at level 70, no associativity) : nat_scope.\nNotation \"x ≥ y\" := (ge x y) (at level 70, no associativity) : nat_scope.\n\nNotation \"x ≤ y\" := (x <= y)%R (at level 70, no associativity) : R_scope.\nNotation \"x ≥ y\" := (x >= y)%R (at level 70, no associativity) : R_scope."
    },
    {
      "type": "text",
      "text": "## **Scopes and coercions**"
    },
    {
      "type": "code",
      "text": "Notation \"'ℕ'\" := (nat).\nNotation \"'ℤ'\" := (Z).\nNotation \"'ℚ'\" := (Q).\nNotation \"'ℝ'\" := (R).\n\n(** We use coercions to get around writing INR and IZR *)\nCoercion INR: nat >-> R.\nCoercion IZR: Z >-> R.\nCoercion Q2R: Q >-> R.\n\n(** Add field and lra to tactics to try automatically *)\nHint Extern 3 ( _ = _ ) => field : real.\nHint Extern 3 ( _ <= _ ) => lra : real.\nHint Extern 3 ( _ >= _ ) => lra : real.\nHint Extern 3 ( _ < _ ) => lra : real.\nHint Extern 3 ( _ > _ ) => lra : real."
    },
    {
      "type": "text",
      "text": "## **Sequences**"
    },
    {
      "type": "code",
      "text": "Definition converges_to (a : ℕ → ℝ) (c : ℝ) :=\n  ∀ ε : ℝ, ε > 0 ⇒ \n    ∃ N : ℕ, ∀ n : ℕ, (n ≥ N)%nat ⇒\n      R_dist (a n) c < ε.\n\nDefinition convergence {M : Metric_Space} (a : ℕ → Base M) (c : Base M) :=\n  ∀ ε : ℝ, ε > 0 ⇒\n    ∃ N : ℕ, ∀ n : ℕ, (n ≥ N)%nat ⇒\n      dist M (a n) c < ε.\n      \nNotation \"a ⟶ c\" := (converges_to a c) (at level 20)."
    },
    {
      "type": "text",
      "text": "## Real numbers\n\nWe have to take care with the associative leve.\nWhen using this in rewrites, $<$, $>$, etc. should bind stronger."
    },
    {
      "type": "code",
      "text": "Notation \"| x |\" := (Rabs x) (at level 69, x at level 200).\nNotation \"｜ x - y ｜\" := (R_dist x y) (at level 69, x at level 48, y at level 48)."
    },
    {
      "type": "text",
      "text": "## Suprema and infima"
    },
    {
      "type": "code",
      "text": "Notation is_sup := is_lub.\nNotation is_bdd_above := bound."
    },
    {
      "type": "text",
      "text": "## Sums and series"
    },
    {
      "type": "code",
      "text": "Notation \"'Σ' Cn 'equals' x\" := \n  (infinite_sum Cn x) (at level 50).\n  \n(*Notation \"'Σ' 'of' Cn 'up' 'to' n\" := \n  (sum_f_R0 Cn n) (at level 50). \n (*Sum and series also defined in series.wpn. What to adapt?*)*)"
    },
    {
      "type": "text",
      "text": "## Functions"
    },
    {
      "type": "text",
      "text": "For the composition of a sequence and a function (e.g. for the sequence of measures of a sequence of sets):"
    },
    {
      "type": "code",
      "text": "(*Notation \"μ ◦ C\" := \n  (fun (n:ℕ) ↦ (μ (C n))) (at level 45).*)"
    },
    {
      "type": "text",
      "text": "## Sets"
    },
    {
      "type": "code",
      "text": "Definition is_in {D : Set} := fun (A : (D → Prop)) ↦ (fun (x : D) ↦ A x).\nNotation \"x ∈ A\" := (@is_in _ A x) (at level 50) : analysis_scope."
    }
  ]
}